#!/usr/bin/env python
""" CSeq C Sequentialization Framework
    command-line front-end
"""
FRAMEWORK_VERSION = "CSeq-Wrapper-1.3"

"""
Description:
    - Swarm

TODO:
    -

Changelog:
    2018.07.09  Option -c for config as command-line argument and stream parsing of json files
    2017.12.19  Add dump-env option for cex generation
    2016.09.14  Initial version
"""

import builtins, getopt, glob, importlib, inspect, os.path, re, shutil, sys, time, traceback
from time import gmtime, strftime
from tempfile import NamedTemporaryFile
import pycparser
from pycparser.plyparser import ParseError
import core.config, core.merger, core.module, core.parser, core.utils
import copy
import json
from ijson.common import ObjectBuilder


class cseqenv:
    cmdline = None      # full command-line
    opts = None         # command-line option-value pairs, e.g. (--input, "file.c")
    args = None         #

    params = []         # additional front-end input parameters
    paramIDs = []       # parameters ID only
    paramvalues = {}    # param values indexed by param ID

    debug = False       # verbosity level
    showsymbols = False #

    chainfile = None    # file with the sequence of modules to execute

    inputfile = None    # input source file to process
    includepath = None  # #include path (for source merging)
    outputfile = None   # TODO not implemented yet

    modules = []        # modules (each performing a single code trasformation)
    transforms = 0      # no. of modules executed so far

    maps = []
    lastlinenoinlastmodule = 0
    outputtofiles = []    # map from merged sources (= Merger"s output) to original source file

    # swarm
    contextswitch = False
    intervals = {}
    configFile = ""
    configString = ""
    premodules = []     # list of premodules of swarm
    aftermodules = []   # list of aftermodule of swarm
    listfile = None   # TODO not implemented yet
    savecommand = {}
    loadcommand = {}


def getInputParamValue(cseqenv,id):
    if id in cseqenv.paramvalues:return cseqenv.paramvalues[id]
    return None


def parseChainCommand(s):
    ret = {}
    l = s.split()
    for i in l:
        pair = i.split("=")
        if len(pair) != 2:
            print("Load file error (%s):\n" % s)
            sys.exit(1)
        ret[pair[0]] = pair[1]

    return ret

def moduleparamusage(p):
    abc = "--%s" % (p.id)
    abc += " <%s>" % p.datatype if p.datatype else ""

    opt = "optional" if p.optional else ""
    opt += ", " if p.optional and p.default else ""
    opt += "default:%s%s%s" % (core.utils.colors.HIGHLIGHT,p.default,core.utils.colors.NO) if p.default else ""
    opt = "(%s)" % opt if len(opt) > 0 else opt

    desc = ("\n    "+" "*26).join([l for l in p.description.split("\n")]) # multiline description

    return "%-26s %s %s" % (abc, desc, opt)


def usage(cmd, errormsg, showhelp=True, detail=False):
    """
        long help (-H) provides the list of all input and output parameters
        for each module.

        short help (-h) provides only those input parameters
        that must be provided in the command-line

        (i.e. for each module the ones not generated by any of the previous
        modules in the configuration)
    """

    if showhelp:
        print("")
        print("  CSeq Lazy |  September 2016")
        print("")
        print("Usage: ")
        print("")
        print("   %s -h [-l <config>]" % cmd)
        print("   %s -i <input.c> [options]" % cmd)
        print("")
        print(" configuration options: ")
        print("   -l,--load=<file>       configuration to use (default:%s%s%s)"
              % (core.utils.colors.HIGHLIGHT, core.config.defaultswarmchain, core.utils.colors.NO))
        print("   -L,--list-chains       show available configurations")
        print("")
        print(" input options:")
        print("   -i,--input=<file>      input filename")
        print("   -I,--include=<path>    include search path (use : as a separator) (default:%s./%s)"
              % (core.utils.colors.HIGHLIGHT,core.utils.colors.NO))
        print("")

        # Module-specific params for the given chain (or for the default one)
        print(" module options:")

        outputparamssofar = []   # used to check which module input params are front-end input
        inputparamssofar = []

        for m in cseqenv.modules + cseqenv.aftermodules:
            if detail:
                print("  [%s]" % m.getname())
                if len(m.inputparamdefs) == len(m.outputparamdefs) == 0: print("")

            try:
                if detail:
                    if len(m.inputparamdefs) > 0: print( "     input:")

                for p in m.inputparamdefs:
                    if (p.id not in [q.id for q in outputparamssofar] and
                    p.id not in [q.id for q in inputparamssofar]):
                        inputparamssofar.append(p)
                        print("   "+moduleparamusage(p))
                    elif detail:
                        print("  ("+moduleparamusage(p)+")")

                if detail and len(m.inputparamdefs) > 0: print("")

                if detail:
                    if len(m.outputparamdefs) > 0: print("     output:")

                for p in m.outputparamdefs:
                    outputparamssofar.append(p)
                    if detail:
                        abc = "--%s" % (p.id)
                        print("   %-26s %s" % (abc, p.description))

                if detail and len(m.outputparamdefs) > 0: print("")

            except Exception as e:
                print("Module error %s :\n%s.\n" % (m.getname(), str(e)))
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)

        print("")
        print(" swarm options: ")
        print("   -Y, --contextswitch        show the number of context switch and exit")
        print("   -C, --config-swarm<X>      configuration file for swarm translation")
        print("   -c, --config-string<X>     configuration string for swarm translation (one instance)")
        print("   -Z, --list-instance<X>     list of instances")
        print("   --suffix<X>                suffix for swarm directory")
        print("")
        print(" other options: ")
        print("   -h, --help                 show help")
        print("   -H, --detailedhelp         show detailed configuration-specific help")
        print("   -v  --version              show version number")
        print("")

    if errormsg:
        print(errormsg + "\n")
        sys.exit(1)

    sys.exit(0)


def listmodulechains():
    list = ""
    for filename in glob.glob("modules/*.chain"): list += filename[len("modules/"):-len(".chain")] + ", "
    if list.endswith(", "): list = list[:-2]
    return list


def main():
    """                   """
    """ I. Initialisation """
    """                   """
    cseqenv.cmdline = sys.argv
    cseqenv.starttime = time.time()    # save wall time

    # Extract the configuration from the command-line or set it to the default.
    cseqenv.chainname = core.utils.extractparamvalue(cseqenv.cmdline, "-l","--load", core.config.defaultswarmchain)
    cseqenv.chainfile = "modules/%s.chain" % core.utils.extractparamvalue(cseqenv.cmdline, "-l","--load", core.config.defaultswarmchain)

    if not core.utils.fileExists(cseqenv.chainfile):
        usage(cseqenv.cmdline[0], "error: unable to open configuration file (%s)" % cseqenv.chainfile, showhelp=False)

    swarmmod = False
    suffix = ""
    loadtype = 0   # normal
    dumpEnv = False

    # Import all modules in the current configuration.
    for modulename in core.utils.printFile(cseqenv.chainfile).splitlines():
        if not modulename.startswith("#") and len(modulename) >= 1:
            modulename = modulename.strip()
            loadtype = 0

            if modulename == "@swarm":
                swarmmod = True
                continue

            if modulename.startswith("@save"):
                cseqenv.savecommand = parseChainCommand(modulename.replace("@save", "").strip())
                continue

            if modulename.startswith("@load"):
                cseqenv.loadcommand = parseChainCommand(modulename.replace("@load", "").strip())
                continue

            if modulename.startswith("@pre"):
                modulename = modulename.replace("@pre", "").strip()
                loadtype = 1 # pre

            if modulename.startswith("@after"):
                modulename = modulename.replace("@after", "").strip()
                loadtype = 2 # after

            try:
                mod = importlib.import_module("modules."+modulename)
                if loadtype == 0:
                    cseqenv.modules.append(getattr(mod, modulename)())
                elif loadtype == 1:
                    cseqenv.premodules.append(getattr(mod, modulename)())
                else:
                    cseqenv.aftermodules.append(getattr(mod, modulename)())
            except ImportError as e:
                print("Unable to import module %s,\nplease check installation.\n" % modulename)
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)
            except AttributeError as e:
                print("Unable to load module %s,\nplease check that the module filename,"
                      "\nthe entry in the chain-file"
                      "and\nthe top-level classname in the module correctly match.\n" % modulename)
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)
            except Exception as e:
                print("Unable to initialise module %s:\n%s.\n" % (modulename, str(e)))
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)

    # Init modules.
    for m in cseqenv.modules:
        try:
            if "init" in dir(m):
                m.init()
        except Exception as e:
            print("Unable to initialise module %s:\n%s.\n" % (m.getname(), str(e)))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)

    # Init pre modules.
    for m in cseqenv.premodules:
        try:
            if "init" in dir(m):
                m.init()
        except Exception as e:
            print("Unable to initialise module %s:\n%s.\n" % (m.getname(), str(e)))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)

    # Init after modules.
    for m in cseqenv.aftermodules:
        try:
            if "init" in dir(m):
                m.init()
        except Exception as e:
            print ("Unable to initialise module %s:\n%s.\n" % (m.getname(), str(e)))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)

    # Init module parameters.
    #
    # Modules can have input and output parameters.
    # Any module input that is not the output of a previous module
    # is a front-end parameter
    # (it is displayed in the usage() screen, and
    #  it can be provided to the front-end in the command-line)
    inParams = []      # module-specific input parameters seen so far
    inParamIDs = []
    inparamvalues = {}

    outParams = []     # module-specific output parameters seen so far
    outParamIDs = []
    outparamvalues = {}

    for m in cseqenv.modules + cseqenv.aftermodules:
        try:
            for p in m.inputparamdefs:  # global input params seen so far
                if p.id not in inParamIDs:
                    inParamIDs.append(p.id)
                    inParams.append(p)

                # if the input param  p  is new and
                # no previous module generates it
                # (i.e., it is not an output param for any previous module)
                # then it needs to be a global (front-end) input
                if p.id not in outParamIDs:
                    cseqenv.paramIDs.append(p.id)
                    cseqenv.params.append(p)

            for p in m.outputparamdefs:  # output params seen so far
                if p.id not in outParamIDs:
                    outParamIDs.append(p.id)
                    outParams.append(p)

        except Exception as e:
            print ("Unable to initialise module %s:\n%s.\n" % (m.getname(), str(e)))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)

    """                """
    """ II. Parameters """
    """                """
    # Parse command-line.
    try:
        shortargs = "hHdi:o:I:e:DSMvl:LC:c:YZ:"
        longargs = [ "help", "detailedhelp", "detail", "input=", "output=", "include=",
                     "error-label=",
                     "debug", "symbols", "modules", "version",
                     "load=", "list-chains",
                     "config-swarm=", "config-string=", "contextswitch", "list-instance=", "suffix=", "dump-env"
                     ]    # <-- append module params here

        # add one command-line parameter for each module-specific parameter
        for p in cseqenv.params:
            longargs.append("%s%s" % (p.id, "" if p.isflag() else "="))

        cseqenv.opts, cseqenv.args = getopt.getopt(sys.argv[1:], shortargs, longargs)
    except getopt.GetoptError as err:
        usage(cseqenv.cmdline[0], "error: " +str(err))

    for o, a in cseqenv.opts:
        if   o in ("-v", "--version")       : print(FRAMEWORK_VERSION); return
        elif o in ("-h", "--help")          : usage(cseqenv.cmdline[0],"")
        elif o in ("-H", "--detailedhelp")  : usage(cseqenv.cmdline[0],"",detail=True)
        elif o in ("-l", "--load")          : pass # handled beforehand, see above
        elif o in ("-L", "--list-modules")  : print(listmodulechains()); sys.exit(0)
        elif o in ("-D", "--debug")         : cseqenv.debug = True
        elif o in ("-S", "--showsymbols")   : cseqenv.showsymbols = True
        elif o in ("-d", "--detail")        : detail = True
        elif o in ("-i", "--input")         : cseqenv.inputfile = a
        elif o in ("-o", "--output")        : cseqenv.outputfile = a
        elif o in ("-I", "--include")       : cseqenv.includepath = a
        elif o in ("-C", "--config-swarm")  : cseqenv.configFile = a
        elif o in ("-c", "--config-string") : cseqenv.configString = a
        elif o in ("-Y", "--contextswitch") : cseqenv.contextswitch = True
        elif o in ("-Z", "--list-instance") : cseqenv.listfile = a
        elif o in ("--suffix", ) : suffix = a
        elif o in ("--dump-env", ) : dumpEnv = True
        else: # module-specific parameters
            cseqenv.paramvalues[o[2:]] = a

    # Basic parameter check.
    if not cseqenv.inputfile: usage(cseqenv.cmdline[0], "error: input file name not specified.")
    if not core.utils.fileExists(cseqenv.inputfile): usage(cseqenv.cmdline[0], "error: unable to open input file (%s)" % cseqenv.inputfile, showhelp=False)
    if not core.utils.fileExists(cseqenv.chainfile): usage(cseqenv.cmdline[0], "error: unable to open module-chain file (%s)" % cseqenv.chainfile, showhelp=False)

    if cseqenv.configFile != "" and not os.path.isfile(cseqenv.configFile):
        usage(cseqenv.cmdline[0], "error: unable to open configuration file (%s)" % cseqenv.configFile, showhelp=False)

    # All global parameters (calculated above) should be in the command-line.
    for p in cseqenv.params:
        if not p.optional and not p.default:
            usage(cseqenv.cmdline[0], "error: %s (option --%s) not specified." % (p.description, p.id))

    # Debug setup.
    cseqenv.debugpath = core.config.debugpath
    if not os.path.exists(core.config.debugpath):
        os.makedirs(core.config.debugpath)
    elif cseqenv.debug:
        shutil.rmtree(core.config.debugpath)
        os.makedirs(core.config.debugpath)

    """              """
    """ III. Merging """
    """              """
    # Load the input file.
    input = core.utils.printFileRows(cseqenv.inputfile)

    # Patch for SVCOMP2016 .i file
    if cseqenv.inputfile.endswith(".i") and core.utils.isPreprocessed(cseqenv.inputfile):
        input = core.utils.stripIfNeeded(cseqenv.inputfile)[1]
        cseqenv.inputfile = cseqenv.inputfile[:-2] + ".c"
        core.utils.saveFile(cseqenv.inputfile, input)

    dirname, filename = os.path.split(os.path.abspath(cseqenv.inputfile))
    swarmdirname = ""
    if cseqenv.listfile != None:
        # Put the generated instances beside the list file.
        swarmdirname = os.path.dirname(cseqenv.listfile) + "/"
    else:
        swarmdirname = dirname + "/" + filename[:-2] + ".swarm%s/" % suffix
    if not os.path.exists(swarmdirname):
        os.makedirs(swarmdirname)
    seqfile = swarmdirname + "_cs_" + filename

    # Output file
    if cseqenv.listfile == "":
        cseqenv.listfile = swarmdirname + "swarm_instances.list"

    # Merge all the source files into a single string.
    try:
        cseqenv.moduleID = "merger"

        Merger = core.merger.Merger()
        Merger.loadfromstring(input, cseqenv)
        output = Merger.getoutput()
        cseqenv.transforms += 1

        if cseqenv.debug:
            core.utils.saveFile("%s/_00_input___merger.c" % core.config.debugpath, input)
            core.utils.saveFile("%s/_00_marked__merger.c" % cseqenv.debugpath,Merger.markedoutput)
            core.utils.saveFile("%s/_00_output__merger.c" % core.config.debugpath,output)
            core.utils.saveFile("%s/_00_linemap__merger.c" % core.config.debugpath,Merger.getlinenumbertable())

    except ParseError as e:
        print("Parse error (%s):\n" % str(e))
        print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output,Merger.getLineNo(e),
            Merger.getColumnNo(e),5,True), core.utils.colors.NO))
        sys.exit(1)
    except builtins.SystemExit as e: # the module invoked sys.exit()
        sys.exit(1)
    except:
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)

    #
    if cseqenv.showsymbols:
        Parser = core.parser.Parser()
        Parser.loadfromstring(output)
        Parser.ast.show()
        sys.exit(0)

    """                    """
    """ IV. Transformation """
    """                    """
    cseqenv.maps.append(Merger.outputtoinput)
    cseqenv.outputtofiles = Merger.outputtofiles

    # Run all modules in a sequence
    for cseqenv.transforms, m in enumerate(cseqenv.modules):
        try:
            timeBefore = time.time()
            if cseqenv.debug:
                print("/* " + m.getname())
            m.initParams(cseqenv)
            m.loadfromstring(output, cseqenv)
            output = m.getoutput()

            if "inputtooutput" in dir(m):   # linemapping only works on Translator (C-to-C) modules
                cseqenv.maps.append(m.outputtoinput)
                cseqenv.lastlinenoinlastmodule = m.output.count("\n")

            if cseqenv.debug:
                fileno = str(cseqenv.transforms+1).zfill(2)
                core.utils.saveFile("%s/_%s_input___%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.input)
                core.utils.saveFile("%s/_%s_output__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.output)
                try:
                    # core.utils.saveFile("%s/_%s_ast__%s.c" % (cseqenv.debugpath,fileno,m.getname()), str(m.Parser.ast.show()))
                    core.utils.saveFile("%s/_%s_symbols__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.Parser.printsymbols())
                except AttributeError:
                    pass
                print("[%s] ok %0.2fs */" % (fileno, int(time.time()) - int(timeBefore)))

            if cseqenv.debug and "markedoutput" in dir(m): # current module is a Translator
                core.utils.saveFile("%s/_%s_marked__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.markedoutput)
                core.utils.saveFile("%s/_%s_linemap__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.getlinenumbertable())

        except ParseError as e:
            print("Parse error (%s) while performing %s->%s:\n" % (str(e),
            cseqenv.modules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.modules[cseqenv.transforms].getname()))
            print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output, m.getLineNo(e), m.getColumnNo(e), 5, True), core.utils.colors.NO))
            sys.exit(1)
        except core.module.ModuleParamError as e:
            print("Module error (%s).\n" % (str(e)))
            sys.exit(1)
        except core.module.ModuleError as e:
            print("Error from %s module: %s.\n" % (cseqenv.modules[cseqenv.transforms].getname(), str(e)[1:-1]))
            sys.exit(1)
        except KeyboardInterrupt as e:
            sys.exit(1)
        except ImportError as e:
            print("Import error (%s),\nplease re-install the tool.\n" % str(e))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)
        except Exception as e:
            print("Error while performing %s->%s:\n"
            % (cseqenv.modules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.modules[cseqenv.transforms].getname()))
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)

    # Swarm Generator
    if cseqenv.contextswitch:
        # Run all modules in a sequence
        for cseqenv.transforms, m in enumerate(cseqenv.aftermodules):
            try:
                timeBefore = time.time()
                if cseqenv.debug:
                    print("/* " + m.getname())
                m.initParams(cseqenv)
                m.loadfromstring(output, cseqenv)
                output = m.getoutput()

                if cseqenv.debug:
                    fileno = str(cseqenv.transforms+1).zfill(2)
                    core.utils.saveFile("%s/_%s_input___%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.input)
                    core.utils.saveFile("%s/_%s_output__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.output)
                    try:
                        # core.utils.saveFile("%s/_%s_ast__%s.c" % (cseqenv.debugpath,fileno,m.getname()), str(m.Parser.ast.show()))
                        core.utils.saveFile("%s/_%s_symbols__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.Parser.printsymbols())
                    except AttributeError:
                        pass
                    print("[%s] ok %0.2fs */" % (fileno, int(time.time()) - int(timeBefore)))

                if cseqenv.debug and "markedoutput" in dir(m): # current module is a Translator
                    core.utils.saveFile("%s/_%s_marked__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.markedoutput)
                    core.utils.saveFile("%s/_%s_linemap__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.getlinenumbertable())

            except ParseError as e:
                print("Parse error (%s) while performing %s->%s:\n" % (str(e),
                cseqenv.aftermodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.aftermodules[cseqenv.transforms].getname()))
                print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output, m.getLineNo(e), m.getColumnNo(e), 5, True), core.utils.colors.NO))
                sys.exit(1)
            except core.module.ModuleParamError as e:
                print("Module error (%s).\n" % (str(e)))
                sys.exit(1)
            except core.module.ModuleError as e:
                print("Error from %s module: %s.\n" % (cseqenv.aftermodules[cseqenv.transforms].getname(), str(e)[1:-1]))
                sys.exit(1)
            except KeyboardInterrupt as e:
                sys.exit(1)
            except ImportError as e:
                print("Import error (%s),\nplease re-install the tool.\n" % str(e))
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)
            except Exception as e:
                print("Error while performing %s->%s:\n"
                    % (cseqenv.aftermodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.aftermodules[cseqenv.transforms].getname()))
                traceback.print_exc(file=sys.stdout)
                sys.exit(1)
    else:
        # if the config is given directly in the command line
        if cseqenv.configString != "":
            config = json.loads(cseqenv.configString.replace("\\"", """))
        else:
            config,fd_config = core.utils.parseConfig(cseqenv.configFile)

        # save source code for multiple generation
        cachedOutput = output
        # save environment if there is save and log
        cachedparams = {}
        for item in cseqenv.savecommand:
            if item == "backend" and item not in cseqenv.paramvalues:
                cseqenv.paramvalues[item] = "cbmc"
            if item == "rounds" and item in cseqenv.paramvalues and int(cseqenv.paramvalues[item]) > 1:
                cseqenv.savecommand[item] = cseqenv.paramvalues[item]
            if item in cseqenv.paramvalues:
                cachedparams[item] = cseqenv.paramvalues[item]

        with open(cseqenv.listfile, "w") as fout:
            try:
                # Cache object and modules
                cachedAftermodules = copy.deepcopy(cseqenv.aftermodules)
                cachedCseqenvMaps = copy.deepcopy(cseqenv.maps)
                cachedCseqenvOutputtofiles = copy.deepcopy(cseqenv.outputtofiles)
                cachedCseqenvParamvalues = copy.deepcopy(cseqenv.paramvalues)
            except copy.error as e:
                raise e

            # Generating instances
            i = -1            # counter
            c = "-"           # name of the current tiling (ex "s17")
            intervals = None  # configuration of the current tiling (ex "[1-3],[7,9]")

            # here "config" streams raw data from the json configuration file
            # we need to assemble it using ijson.ObjectBuilder
            for prefix, event, value in config:
                if prefix == "" and event == "map_key":  # found new tiling "s..."
                    c = value  # mark the key value
                    builder = ObjectBuilder()
                    continue
                elif prefix.startswith(c):  # while at this key, build the object
                    builder.event(event, value)
                    if event == "end_map":  # found the end of an object at the current key
                        # print "(%s,%s)" % (c, builder.value)
                        intervals = builder.value
                        i += 1
                        # now we can process the fully loaded tiling
                    else:
                        continue # tiling not complete yet
                else:
                    continue # tiling not complete yet

                # Restore cache
                try:
                    cseqenv.aftermodules = copy.deepcopy(cachedAftermodules)
                    cseqenv.maps = copy.deepcopy(cachedCseqenvMaps)
                    cseqenv.outputtofiles = copy.deepcopy(cachedCseqenvOutputtofiles)
                    cseqenv.paramvalues = copy.deepcopy(cachedCseqenvParamvalues)

                except copy.error as e:
                    raise e

                cseqenv.intervals = intervals
                swarmseqfile = seqfile[:-2] + "__instance_%s_%s.c" % (i, c)
                temporaryfile = NamedTemporaryFile()


                # Set environment for pre-module if applicable
                for item in cseqenv.savecommand:
                    if cseqenv.savecommand[item] == "tempfile":
                        cseqenv.paramvalues[item] = temporaryfile.name
                    else:
                        cseqenv.paramvalues[item] = cseqenv.savecommand[item]

                cseqenv.outputfile = swarmseqfile

                # Pre-modules
                timepremodules = time.time()
                output = cachedOutput

                # Premodules are design for Frama-C stuff so line maps will not be counted
                for cseqenv.transforms, m in enumerate(cseqenv.premodules):
                    try:
                        timeBefore = time.time()
                        if cseqenv.debug:
                            print("/* " + m.getname())
                        m.initParams(cseqenv)
                        m.loadfromstring(output, cseqenv)
                        output = m.getoutput()

                        if cseqenv.debug:
                            fileno = str(cseqenv.transforms+1).zfill(2)
                            core.utils.saveFile("%s/_%s_input___%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.input)
                            core.utils.saveFile("%s/_%s_output__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.output)
                            try:
                                # core.utils.saveFile("%s/_%s_ast__%s.c" % (cseqenv.debugpath,fileno,m.getname()), str(m.Parser.ast.show()))
                                core.utils.saveFile("%s/_%s_symbols__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.Parser.printsymbols())
                            except AttributeError:
                                pass
                            print("[%s] ok %0.2fs */" % (fileno, int(time.time()) - int(timeBefore)))

                        if cseqenv.debug and "markedoutput" in dir(m): # current module is a Translator
                            core.utils.saveFile("%s/_%s_marked__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.markedoutput)
                            core.utils.saveFile("%s/_%s_linemap__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.getlinenumbertable())


                    except ParseError as e:
                        print("Parse error (%s) while performing %s->%s:\n" % (str(e),
                            cseqenv.premodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.premodules[cseqenv.transforms].getname()))
                        print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output, m.getLineNo(e), m.getColumnNo(e), 5, True), core.utils.colors.NO))
                        sys.exit(1)
                    except core.module.ModuleParamError as e:
                        print("Module error (%s).\n" % (str(e)))
                        sys.exit(1)
                    except core.module.ModuleError as e:
                        print("Error from %s module: %s.\n" % (cseqenv.premodules[cseqenv.transforms].getname(), str(e)[1:-1]))
                        sys.exit(1)
                    except KeyboardInterrupt as e:
                        sys.exit(1)
                    except ImportError as e:
                        print("Import error (%s),\nplease re-install the tool.\n" % str(e))
                        traceback.print_exc(file=sys.stdout)
                        sys.exit(1)
                    except Exception as e:
                        print("Error while performing %s->%s:\n"
                            % (cseqenv.premodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.premodules[cseqenv.transforms].getname()))
                        traceback.print_exc(file=sys.stdout)
                        sys.exit(1)

                # After-modules
                # remove added parameter
                for item in cseqenv.savecommand:
                    if item in cseqenv.paramvalues:
                        del cseqenv.paramvalues[item]
                # restore cached parameter
                for item in cachedparams:
                    cseqenv.paramvalues[item] = cachedparams[item]

                for item in cseqenv.loadcommand:
                    if item.startswith("env."):   # which mean the environment gonna be set
                        attri = item.replace("env.", "")
                        if cseqenv.loadcommand[item] == "<get_time>":
                            setattr(cseqenv, attri, time.time() - timepremodules)
                        else:
                            setattr(cseqenv, attri, cseqenv.loadcommand[item])
                    else:
                        if cseqenv.loadcommand[item] == "tempfile":
                            cseqenv.paramvalues[item] = temporaryfile.name

                output = cachedOutput
                for cseqenv.transforms, m in enumerate(cseqenv.aftermodules):
                    try:
                        timeBefore = time.time()
                        if cseqenv.debug:
                            print("/* " + m.getname())
                        m.initParams(cseqenv)
                        m.loadfromstring(output, cseqenv)
                        output = m.getoutput()

                        if "inputtooutput" in dir(m):   # linemapping only works on Translator (C-to-C) modules
                            cseqenv.maps.append(m.outputtoinput)
                            cseqenv.lastlinenoinlastmodule = m.output.count("\n")

                        if cseqenv.debug:
                            fileno = str(cseqenv.transforms+1).zfill(2)
                            core.utils.saveFile("%s/_%s_input___%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.input)
                            core.utils.saveFile("%s/_%s_output__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.output)
                            try:
                                # core.utils.saveFile("%s/_%s_ast__%s.c" % (cseqenv.debugpath,fileno,m.getname()), str(m.Parser.ast.show()))
                                core.utils.saveFile("%s/_%s_symbols__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.Parser.printsymbols())
                            except AttributeError:
                                pass
                            print("[%s] ok %0.2fs */" % (fileno, int(time.time()) - int(timeBefore)))

                        if cseqenv.debug and "markedoutput" in dir(m): # current module is a Translator
                            core.utils.saveFile("%s/_%s_marked__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.markedoutput)
                            core.utils.saveFile("%s/_%s_linemap__%s.c" % (cseqenv.debugpath,fileno,m.getname()),m.getlinenumbertable())

                    except ParseError as e:
                        print("Parse error (%s) while performing %s->%s:\n" % (str(e),
                            cseqenv.aftermodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.aftermodules[cseqenv.transforms].getname()))
                        print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output, m.getLineNo(e), m.getColumnNo(e), 5, True), core.utils.colors.NO))
                        sys.exit(1)
                    except core.module.ModuleParamError as e:
                        print("Module error (%s).\n" % (str(e)))
                        sys.exit(1)
                    except core.module.ModuleError as e:
                        print("Error from %s module: %s.\n" % (cseqenv.aftermodules[cseqenv.transforms].getname(), str(e)[1:-1]))
                        sys.exit(1)
                    except KeyboardInterrupt as e:
                        sys.exit(1)
                    except ImportError as e:
                        print("Import error (%s),\nplease re-install the tool.\n" % str(e))
                        traceback.print_exc(file=sys.stdout)
                        sys.exit(1)
                    except Exception as e:
                        print("Error while performing %s->%s:\n"
                            % (cseqenv.aftermodules[cseqenv.transforms-1].getname() if cseqenv.transforms>0 else "", cseqenv.aftermodules[cseqenv.transforms].getname()))
                        traceback.print_exc(file=sys.stdout)
                        sys.exit(1)

                core.utils.saveFile(swarmseqfile, output)
                fout.write("%s\n" % swarmseqfile)

                # Write json log file for counterexample generator
                if dumpEnv:
                    """ Dump cseq environment to json file for counter example
                    """
                    dumpObj = {}
                    dumpObj["maps"] = cseqenv.maps
                    dumpObj["backend"] = getInputParamValue(cseqenv, "backend")
                    dumpObj["threadnamesmap"] = getInputParamValue(cseqenv, "threadnamesmap")
                    dumpObj["threadindexes"] = getInputParamValue(cseqenv, "threadindexes")
                    dumpObj["threadindextoname"] = getInputParamValue(cseqenv, "threadindextoname")
                    dumpObj["varnamesmap"] = getInputParamValue(cseqenv, "varnamesmap")
                    dumpObj["coordstofunctions"] = core.utils.json_serialize(getInputParamValue(cseqenv, "coordstofunctions"))
                    dumpObj["outputtofiles"] = cseqenv.outputtofiles

                    with open(cseqenv.outputfile[:-1] + "json", "w") as outfile:
                        json.dump(dumpObj, outfile)

                temporaryfile.close()

            if cseqenv.configString != "":
                fd_config.close()
    return


if __name__ == "__main__":
    main()